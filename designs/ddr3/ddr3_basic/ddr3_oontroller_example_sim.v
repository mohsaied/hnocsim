// ddr3_oontroller_example_sim.v

// This file was auto-generated from alt_mem_if_ddr3_tg_eds_hw.tcl.  If you edit it your changes
// will probably be lost.
// 
// Generated using ACDS version 14.0 200 at 2015.03.04.21:55:58

`timescale 1 ps / 1 ps
module ddr3_oontroller_example_sim ();

	wire         e0_afi_clk_clk;                   // e0:afi_clk -> t0:clk
	wire         e0_afi_reset_reset;               // e0:afi_reset_n -> t0:reset_n
	wire         e0_drv_status_test_complete;      // e0:drv_status_test_complete -> t0:test_complete
	wire         e0_drv_status_fail;               // e0:drv_status_fail -> t0:fail
	wire         e0_drv_status_pass;               // e0:drv_status_pass -> t0:pass

	wire    [2:0] d0_avl_burstcount;               // d0:avl_size -> mm_interconnect_0:d0_avl_burstcount
	wire          d0_avl_waitrequest;              // mm_interconnect_0:d0_avl_waitrequest -> d0:avl_ready
	wire  [511:0] d0_avl_writedata;                // d0:avl_wdata -> mm_interconnect_0:d0_avl_writedata
	wire   [28:0] d0_avl_address;                  // d0:avl_addr -> mm_interconnect_0:d0_avl_address
	wire          d0_avl_write;                    // d0:avl_write_req -> mm_interconnect_0:d0_avl_write
	wire          d0_avl_read;                     // d0:avl_read_req -> mm_interconnect_0:d0_avl_read
	wire  [511:0] d0_avl_readdata;                 // mm_interconnect_0:d0_avl_readdata -> d0:avl_rdata
	wire   [63:0] d0_avl_byteenable;               // d0:avl_be -> mm_interconnect_0:d0_avl_byteenable
	wire          d0_avl_readdatavalid;            // mm_interconnect_0:d0_avl_readdatavalid -> d0:avl_rdata_valid
    
    
    /*
    ddr3_oontroller_example_sim_e0_d0 #(
		.DEVICE_FAMILY                          ("Stratix V"),
		.TG_AVL_DATA_WIDTH                      (512),
		.TG_AVL_ADDR_WIDTH                      (29),
		.TG_AVL_WORD_ADDR_WIDTH                 (23),
		.TG_AVL_SIZE_WIDTH                      (3),
		.TG_AVL_BE_WIDTH                        (64),
		.DRIVER_SIGNATURE                       (1431634060),
		.TG_GEN_BYTE_ADDR                       (1),
		.TG_NUM_DRIVER_LOOP                     (1),
		.TG_ENABLE_UNIX_ID                      (0),
		.TG_USE_UNIX_ID                         (0),
		.TG_RANDOM_BYTE_ENABLE                  (1),
		.TG_ENABLE_READ_COMPARE                 (1),
		.TG_POWER_OF_TWO_BURSTS_ONLY            (0),
		.TG_BURST_ON_BURST_BOUNDARY             (0),
		.TG_DO_NOT_CROSS_4KB_BOUNDARY           (0),
		.TG_TIMEOUT_COUNTER_WIDTH               (32),
		.TG_MAX_READ_LATENCY                    (20),
		.TG_SINGLE_RW_SEQ_ADDR_COUNT            (32),
		.TG_SINGLE_RW_RAND_ADDR_COUNT           (32),
		.TG_SINGLE_RW_RAND_SEQ_ADDR_COUNT       (32),
		.TG_BLOCK_RW_SEQ_ADDR_COUNT             (8),
		.TG_BLOCK_RW_RAND_ADDR_COUNT            (8),
		.TG_BLOCK_RW_RAND_SEQ_ADDR_COUNT        (8),
		.TG_BLOCK_RW_BLOCK_SIZE                 (8),
		.TG_TEMPLATE_STAGE_COUNT                (4),
		.TG_SEQ_ADDR_GEN_MIN_BURSTCOUNT         (1),
		.TG_SEQ_ADDR_GEN_MAX_BURSTCOUNT         (4),
		.TG_RAND_ADDR_GEN_MIN_BURSTCOUNT        (1),
		.TG_RAND_ADDR_GEN_MAX_BURSTCOUNT        (4),
		.TG_RAND_SEQ_ADDR_GEN_MIN_BURSTCOUNT    (1),
		.TG_RAND_SEQ_ADDR_GEN_MAX_BURSTCOUNT    (4),
		.TG_RAND_SEQ_ADDR_GEN_RAND_ADDR_PERCENT (50)
	) d0 (
		.clk             (e0_afi_clk_clk),                   // avl_clock.clk
		.reset_n         (e0_afi_reset_reset),               // avl_reset.reset_n
		.pass            (e0_drv_status_pass),           //    status.pass
		.fail            (e0_drv_status_fail),           //          .fail
		.test_complete   (e0_drv_status_test_complete),  //          .test_complete
		.avl_ready       (~d0_avl_waitrequest),       //       avl.waitrequest_n
		.avl_addr        (d0_avl_address),            //          .address
		.avl_size        (d0_avl_burstcount),         //          .burstcount
		.avl_wdata       (d0_avl_writedata),          //          .writedata
		.avl_rdata       (d0_avl_readdata),           //          .readdata
		.avl_write_req   (d0_avl_write),              //          .write
		.avl_read_req    (d0_avl_read),               //          .read
		.avl_rdata_valid (d0_avl_readdatavalid),      //          .readdatavalid
		.avl_be          (d0_avl_byteenable),         //          .byteenable
		.avl_burstbegin  ()                           //          .beginbursttransfer
	);
    */
   
   ddr3_tester ddr3_tester_inst (
        .clk(e0_afi_clk_clk),
        .rst(r0_afi_reset_reset),
        .burstcount(d0_avl_burstcount),
        .waitrequest(d0_avl_waitrequest),
        .writedata(d0_avl_writedata),
        .address(d0_avl_address),
        .write(d0_avl_write),
        .read(d0_avl_read),
        .readdata(d0_avl_readdata),
        .byteenable(d0_avl_byteenable),
        .readdatavalid(d0_avl_readdatavalid)
   );

    
    ddr3_top ddr3_inst(
        .e0_afi_clk_clk               (e0_afi_clk_clk),              // avl_clock.clk
		.e0_afi_reset_reset           (e0_afi_reset_reset),          // avl_reset.reset_n
		.e0_drv_status_pass           (e0_drv_status_pass),          //    status.pass
		.e0_drv_status_fail           (e0_drv_status_fail),          //          .fail
		.e0_drv_status_test_complete  (e0_drv_status_test_complete), //          .test_complete
		.d0_avl_waitrequest           (d0_avl_waitrequest),          //       avl.waitrequest_n
		.d0_avl_address               (d0_avl_address),              //          .address
		.d0_avl_burstcount            (d0_avl_burstcount),           //          .burstcount
		.d0_avl_writedata             (d0_avl_writedata),            //          .writedata
		.d0_avl_readdata              (d0_avl_readdata),             //          .readdata
		.d0_avl_write                 (d0_avl_write),                //          .write
		.d0_avl_read                  (d0_avl_read),                 //          .read
		.d0_avl_readdatavalid         (d0_avl_readdatavalid),        //          .readdatavalid
		.d0_avl_byteenable            (d0_avl_byteenable)            //          .byteenable
    );
    
endmodule
